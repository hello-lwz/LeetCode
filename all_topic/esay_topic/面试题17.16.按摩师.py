#!/usr/local/bin/python3
# -*- coding:utf-8 -*-
"""
@author: 
@file: 面试题17.16.按摩师.py
@time: 2020/2/28 17:56
@desc: 
"""
"""
一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，
因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
注意：本题相对原题稍作改动
示例 1：

输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
示例 2：

输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
示例 3：

输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
"""
class Solution(object):
    def massage(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        """
        利用常规的动态规划
            1.判断nums的长度 0就返回0 1就返回第一个元素（因为我么得选择）
            2.创建一个列表dp=[0] * len(nums)
            3.dp的第一个元素等于nums的第一个元素，第二个元素等于nums的第一个元素与第二个元素的最大值
            4.从索引2开始循环nums
            5.两种选择。 1.选择该预约 则dp[i] = dp[i-2] + nums[i] (若选择该预约等于i-2的最长时长+本次预约时长)
                        2.不选择该预约 则dp[i] = dp[i-1] (不选择该预约则最长时长仍等于上一个预约的时长)
            6.返回dp最后一个元素（dp每个元素表示到该预约的最长时长）
        """
        if not nums:
            return 0
        elif len(nums) == 1:
            return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[1], nums[0])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        return dp[-1]


a = Solution().massage([2,1,4,5,3,1,1,3])
print(a)